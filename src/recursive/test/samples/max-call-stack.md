\n\nManual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. The fix is non-trivial and likely requires significant redesign.\n\n### Proof of Concept\nNote the `c0` in the last argument of the call data (invalid UTF8).\n\nIt can be triggered with:\n\n`solidity\ndata memory bytes = hex\"f7955637000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000461746f6d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000046e616d6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000673796d626fc00000000000000000000000000000000000000000000000000000\";\ngravity.call(data);\n`\n\nThe log output is as follows:\n`solidity\n    ERC20DeployedEvent(\"atom\", \"name\", ❮utf8 decode failed❯: 0x73796d626fc0, 18, 2)\n`\n\nWhich hits [this code path](\n\n`rust\n    let symbol = String::from_utf8(input.data[index_start..index_end].to_vec());\n    trace!(\"Symbol {:?}\", symbol);\n    if symbol.is_err() {\n        return Err(GravityError::InvalidEventLogError(format!(\n            \"{:?} is not valid utf8, probably incorrect parsing\",\n            symbol\n        )));\n    }\n`\n\nAnd would cause an early return [here](\n\n`rust\nlet erc20_deploys = Erc20DeployedEvent::from_logs(&deploys)?;\n`\n\nNever updating last checked block and therefore, this will freeze the bridge by disallowing any attestations to take place. This is an extremely low cost way to bring down the network.\n\n#### Recommendation\nThis is a hard one. Re-syncing is permanently borked because, on the Go side, there is seemingly no way to ever process the event nonce because protobufs do not handle non-utf8 strings. The validator would report they need event nonce `N` from the orchestrator, but they can never parse the event `N`. Seemingly, validators & orchestrators would have to know to ignore that specific event nonce. But it is a permissionless function, so it can be used to effectively permanently stop attestations & the bridge until a new `Gravity.sol` is deployed.\n\nOne potential fix is to check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. This likely will be expensive though. Alternatively, you could require that validators sign ERC20 creation requests and perform checks before the transaction is sent.\n\n**[jkilpatr (Althea) confirmed](\n > This is a valid and well considered bug.\n>\n> I do disagree about the difficulty of the fix though, if we fail to parse the token name as utf8 we can just encode the bytes themselves in hex and pass that along. The result will be perfectly valid if a little unergonomic.\n\n**[albertchon (judge) commented](\n > Clever, great catch\n\n